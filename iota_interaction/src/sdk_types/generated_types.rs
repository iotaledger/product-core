// Copyright 2020-2024 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

use fastcrypto::encoding::Base64;
use serde::Deserialize;
use serde::Serialize;

use super::iota_json_rpc_types::iota_transaction::IotaTransactionBlockResponseOptions;
use super::iota_types::quorum_driver_types::ExecuteTransactionRequestType;
use super::types::crypto::Signature;
use super::types::transaction::TransactionData;

use crate::rpc_types::EventFilter;
use crate::rpc_types::IotaObjectDataFilter;
use crate::rpc_types::IotaObjectDataOptions;
use crate::types::dynamic_field::DynamicFieldName;
use crate::types::event::EventID;
use crate::types::iota_serde::SequenceNumber;

// The types defined in this file:
// * do not exist in the iota rust sdk
// * have an equivalent type in the iota typescript sdk
// * are needed for wasm-bindings
// * have been generated by @iota/sdk/typescript/scripts/generate.ts
//
// As there is no equivalent rust type in the iota rust sdk, we need to
// define equivalent rust types here.

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ExecuteTransactionBlockParams {
  /// BCS serialized transaction data bytes without its type tag, as base-64 encoded string.
  transaction_block: Base64,
  /// A list of signatures (`flag || signature || pubkey` bytes, as base-64 encoded string). Signature is committed to
  /// the intent message of the transaction data, as base-64 encoded string.
  signature: Vec<Base64>,
  /// options for specifying the content to be returned
  options: Option<IotaTransactionBlockResponseOptions>,
  /// The request type, derived from `IotaTransactionBlockResponseOptions` if None
  request_type: Option<ExecuteTransactionRequestType>,
}

impl ExecuteTransactionBlockParams {
  pub fn new(
    tx_data: TransactionData,
    signatures: Vec<Signature>,
    options: Option<IotaTransactionBlockResponseOptions>,
    request_type: Option<ExecuteTransactionRequestType>,
  ) -> Self {
    let tx_data_bcs = bcs::to_bytes(&tx_data).expect("this serialization cannot fail");
    let signatures_b64 = signatures
      .into_iter()
      .map(|sig| Base64::from_bytes(sig.as_ref()))
      .collect();
    ExecuteTransactionBlockParams {
      transaction_block: Base64::from_bytes(&tx_data_bcs),
      signature: signatures_b64,
      options,
      request_type,
    }
  }
}

/// Return the dynamic field object information for a specified object
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetDynamicFieldObjectParams {
  /// The ID of the queried parent object
  parent_id: String,
  /// The Name of the dynamic field
  name: DynamicFieldName,
}

impl GetDynamicFieldObjectParams {
  pub fn new(parent_id: String, name: DynamicFieldName) -> Self {
    GetDynamicFieldObjectParams { parent_id, name }
  }
}

/// Return the object information for a specified object
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetObjectParams {
  /// the ID of the queried object
  id: String,
  /// options for specifying the content to be returned
  options: Option<IotaObjectDataOptions>,
}

impl GetObjectParams {
  pub fn new(id: String, options: Option<IotaObjectDataOptions>) -> Self {
    GetObjectParams { id, options }
  }
}

/// Return the list of objects owned by an address. Note that if the address owns more than
/// `QUERY_MAX_RESULT_LIMIT` objects, the pagination is not accurate, because previous page may have
/// been updated when the next page is fetched. Please use iotax_queryObjects if this is a concern.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetOwnedObjectsParams {
  /// the owner's Iota address
  owner: String,
  /// An optional paging cursor. If provided, the query will start from the next item after the specified
  /// cursor. Default to start from the first item if not specified.
  cursor: Option<String>,
  /// Max number of items returned per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified.
  limit: Option<usize>,
  /// If None, no filter will be applied
  filter: Option<IotaObjectDataFilter>,
  /// config which fields to include in the response, by default only digest is included
  options: Option<IotaObjectDataOptions>,
}

impl GetOwnedObjectsParams {
  pub fn new(
    owner: String,
    cursor: Option<String>,
    limit: Option<usize>,
    filter: Option<IotaObjectDataFilter>,
    options: Option<IotaObjectDataOptions>,
  ) -> Self {
    GetOwnedObjectsParams {
      owner,
      cursor,
      limit,
      filter,
      options,
    }
  }
}

/// Return the transaction response object.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetTransactionBlockParams {
  /// the digest of the queried transaction
  digest: String,
  /// options for specifying the content to be returned
  #[serde(skip_serializing_if = "Option::is_none")]
  options: Option<IotaTransactionBlockResponseOptions>,
}

impl GetTransactionBlockParams {
  pub fn new(digest: String, options: Option<IotaTransactionBlockResponseOptions>) -> Self {
    GetTransactionBlockParams { digest, options }
  }
}

/// Note there is no software-level guarantee/SLA that objects with past versions can be retrieved by
/// this API, even if the object and version exists/existed. The result may vary across nodes depending
/// on their pruning policies. Return the object information for a specified version
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TryGetPastObjectParams {
  /// the ID of the queried object
  id: String,
  /// the version of the queried object. If None, default to the latest known version
  version: SequenceNumber,
  //// options for specifying the content to be returned
  options: Option<IotaObjectDataOptions>,
}

impl TryGetPastObjectParams {
  pub fn new(id: String, version: SequenceNumber, options: Option<IotaObjectDataOptions>) -> Self {
    TryGetPastObjectParams { id, version, options }
  }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum SortOrder {
  Ascending,
  Descending,
}

impl SortOrder {
  pub fn new(descending_order: bool) -> Self {
    return if descending_order {
      SortOrder::Descending
    } else {
      SortOrder::Ascending
    };
  }
}

/// Return list of events for a specified query criteria.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct QueryEventsParams {
  /// The event query criteria. See [Event filter](https://docs.iota.io/build/event_api#event-filters)
  /// documentation for examples.
  query: EventFilter,
  /// optional paging cursor
  cursor: Option<EventID>,
  /// maximum number of items per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified.
  limit: Option<usize>,
  /// query result ordering, default to false (ascending order), oldest record first.
  order: Option<SortOrder>,
}

impl QueryEventsParams {
  pub fn new(query: EventFilter, cursor: Option<EventID>, limit: Option<usize>, order: Option<SortOrder>) -> Self {
    QueryEventsParams {
      query,
      cursor,
      limit,
      order,
    }
  }
}

/// Return all Coin<`coin_type`> objects owned by an address.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GetCoinsParams {
  /// the owner's Iota address
  owner: String,
  /// optional type name for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC),
  /// default to 0x2::iota::IOTA if not specified.
  coin_type: Option<String>,
  /// optional paging cursor
  cursor: Option<String>,
  /// maximum number of items per page
  limit: Option<usize>,
}

impl GetCoinsParams {
  pub fn new(owner: String, coin_type: Option<String>, cursor: Option<String>, limit: Option<usize>) -> Self {
    GetCoinsParams {
      owner,
      coin_type,
      cursor,
      limit,
    }
  }
}

/// Params for `wait_for_transaction` / `wait_for_transaction`.
///
/// Be careful when serializing with `serde_wasm_bindgen::to_value`, as `#[serde(flatten)]`
/// will turn the object into a `Map` instead of a plain object in Js.
/// Prefer serializing with `serde_wasm_bindgen::Serializer::json_compatible` or perform custom serialization.
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WaitForTransactionParams {
  /// Block digest and options for content that should be returned.
  #[serde(flatten)]
  get_transaction_block_params: GetTransactionBlockParams,
  /// The amount of time to wait for a transaction block. Defaults to one minute.
  #[serde(skip_serializing_if = "Option::is_none")]
  timeout: Option<u64>,
  /// The amount of time to wait between checks for the transaction block. Defaults to 2 seconds.
  #[serde(skip_serializing_if = "Option::is_none")]
  poll_interval: Option<u64>,
}

impl WaitForTransactionParams {
  pub fn new(
    digest: String,
    options: Option<IotaTransactionBlockResponseOptions>,
    timeout: Option<u64>,
    poll_interval: Option<u64>,
  ) -> Self {
    WaitForTransactionParams {
      get_transaction_block_params: GetTransactionBlockParams::new(digest, options),
      timeout,
      poll_interval,
    }
  }
}
