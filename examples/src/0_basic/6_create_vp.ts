// Copyright 2020-2022 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

import { Client, MnemonicSecretManager } from "@iota/client-wasm/node";
import { Bip39 } from "@iota/crypto.js";
import {
    CoreDocument,
    Credential,
    Duration,
    FailFast,
    IotaIdentityClient,
    JwkMemStore,
    JwsSignatureOptions,
    JwsVerificationOptions,
    JwtCredentialValidationOptions,
    JwtCredentialValidator,
    JwtPresentation,
    JwtPresentationOptions,
    JwtPresentationValidationOptions,
    JwtPresentationValidator,
    KeyIdMemStore,
    Resolver,
    Storage,
    SubjectHolderRelationship,
    Timestamp,
} from "@iota/identity-wasm/node";
import { API_ENDPOINT, createDidStorage } from "../util";

/**
 * This example shows how to create a Verifiable Presentation and validate it.
 * A Verifiable Presentation is the format in which a (collection of) Verifiable Credential(s) gets shared.
 * It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp.
 */
export async function createVP() {
    // ===========================================================================
    // Step 1: Create identities for the issuer and the holder.
    // ===========================================================================

    const client = new Client({
        primaryNode: API_ENDPOINT,
        localPow: true,
    });
    const didClient = new IotaIdentityClient(client);

    // Creates a new wallet and identity (see "0_create_did" example).
    const issuerSecretManager: MnemonicSecretManager = {
        mnemonic: Bip39.randomMnemonic(),
    };
    const issuerStorage: Storage = new Storage(new JwkMemStore(), new KeyIdMemStore());
    let { document: issuerDocument, fragment: issuerFragment } = await createDidStorage(
        client,
        issuerSecretManager,
        issuerStorage,
    );

    // Create an identity for the holder, in this case also the subject.
    const aliceSecretManager: MnemonicSecretManager = {
        mnemonic: Bip39.randomMnemonic(),
    };
    const aliceStorage: Storage = new Storage(new JwkMemStore(), new KeyIdMemStore());
    let { document: aliceDocument, fragment: aliceFragment } = await createDidStorage(
        client,
        aliceSecretManager,
        aliceStorage,
    );

    // ===========================================================================
    // Step 2: Issuer creates and signs a Verifiable Credential.
    // ===========================================================================

    const subject = {
        id: aliceDocument.id(),
        name: "Alice",
        degreeName: "Bachelor of Science and Arts",
        degreeType: "BachelorDegree",
        GPA: "4.0",
    };

    // Create an unsigned `UniversityDegree` credential for Alice
    const unsignedVc = new Credential({
        id: "https://example.edu/credentials/3732",
        type: "UniversityDegreeCredential",
        issuer: issuerDocument.id(),
        credentialSubject: subject,
    });

    const credentialJwt = await issuerDocument.createCredentialJwt(
        issuerStorage,
        issuerFragment,
        unsignedVc,
        new JwsSignatureOptions(),
    );

    const res = new JwtCredentialValidator().validate(
        credentialJwt,
        issuerDocument,
        new JwtCredentialValidationOptions({}),
        FailFast.FirstError,
    );
    console.log("credentialjwt validation", res.intoCredential());

    // ===========================================================================
    // Step 3: Issuer sends the Verifiable Credential to the holder.
    // ===========================================================================

    // The credential is then serialized to JSON and transmitted to the holder in a secure manner.
    // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.
    console.log(`Sending credential (as JWT) to the holder`, unsignedVc.toJSON());

    // ===========================================================================
    // Step 4: Verifier sends the holder a challenge and requests a signed Verifiable Presentation.
    // ===========================================================================

    // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
    const nonce = "475a7984-1bb5-4c4c-a56f-822bccd46440";

    // The verifier and holder also agree that the signature should have an expiry date
    // 10 minutes from now.
    const expires = Timestamp.nowUTC().checkedAdd(Duration.minutes(10));

    // ===========================================================================
    // Step 5: Holder creates a verifiable presentation from the issued credential for the verifier to validate.
    // ===========================================================================

    // Create a Verifiable Presentation from the Credential
    const unsignedVp = new JwtPresentation({
        holder: aliceDocument.id(),
        verifiableCredential: credentialJwt,
    });

    // Sign the verifiable presentation using the holder's verification method
    // and include the requested challenge and expiry timestamp.
    const presentationJwt = await aliceDocument.createPresentationJwt(
        aliceStorage,
        aliceFragment,
        unsignedVp,
        new JwsSignatureOptions({ nonce }),
        new JwtPresentationOptions({ expirationDate: expires }),
    );

    // ===========================================================================
    // Step 6: Holder sends a verifiable presentation to the verifier.
    // ===========================================================================
    console.log(`Sending presentation (as JWT) to the verifier`, unsignedVp.toJSON());

    // ===========================================================================
    // Step 7: Verifier receives the Verifiable Presentation and verifies it.
    // ===========================================================================

    // The verifier wants the following requirements to be satisfied:
    // - Signature verification (including checking the requested challenge to mitigate replay attacks)
    // - Presentation validation must fail if credentials expiring within the next 10 hours are encountered
    // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property
    // - The issuance date must not be in the future.

    // Declare that any credential contained in the presentation are not allowed to expire within the next 10 hours:
    const earliestExpiryDate = Timestamp.nowUTC().checkedAdd(Duration.hours(10));
    const sharedValidationOptions = new JwtCredentialValidationOptions({
        earliestExpiryDate,
    });

    // Declare that the presentation holder's DID must match the subject ID on all credentials in the presentation.
    const subjectHolderRelationship = SubjectHolderRelationship.AlwaysSubject;

    const jwtPresentationValidationOptions = new JwtPresentationValidationOptions({
        presentationVerifierOptions: new JwsVerificationOptions({ nonce }),
        sharedValidationOptions,
        subjectHolderRelationship,
    });

    // In order to validate presentations and credentials one needs to resolve the DID Documents of
    // the presentation holder and of credential issuers. This is something the `Resolver` can help with.
    const resolver = new Resolver({
        client: didClient,
    });

    const presentationDids = JwtPresentationValidator.extractDids(presentationJwt);
    const resolvedHolder = await resolver.resolve(presentationDids.holder.toString());
    const resolvedIssuer = await resolver.resolve(presentationDids.issuers[0].toString());

    // Validate the presentation and all the credentials included in it according to the validation options.
    new JwtPresentationValidator().validate(
        presentationJwt,
        resolvedHolder,
        [resolvedIssuer],
        jwtPresentationValidationOptions,
        FailFast.FirstError,
    );

    // Since no errors were thrown by `verifyPresentation` we know that the validation was successful.
    console.log(`VP successfully validated`);
}
