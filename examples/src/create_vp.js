// Copyright 2020-2021 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

import {
    Credential,
    CredentialValidationOptions,
    Duration,
    FailFast,
    Presentation,
    PresentationValidationOptions,
    Resolver,
    SignatureOptions,
    SubjectHolderRelationship,
    Timestamp,
    VerifierOptions
} from '@iota/identity-wasm';
import {createVC} from './create_vc';

/**
 This example shows how to create a Verifiable Presentation and validate it.
 A Verifiable Presentation is the format in which a (collection of) Verifiable Credential(s) gets shared.
 It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp.

 @param {{network: Network, explorer: ExplorerUrl}} clientConfig
 **/
async function createVP(clientConfig) {
    // An issuer creates and signs a Verifiable Credential and passes it to the credential subject `Alice`.

    // See "createVC" example
    const {alice, credentialJSON} = await createVC(clientConfig);

    // In this example the credential subject Alice will be the presentation holder.

    // ===========================================================================
    // Holder - creates a verifiable presentation from the issued credential for the verifier to validate.
    // ===========================================================================

    // Deserialize the credential.
    const signedVc = Credential.fromJSON(credentialJSON);

    // Create a Verifiable Presentation from the Credential
    const unsignedVp = new Presentation(alice.doc, signedVc.toJSON())

    // The verifier has asked Alice for a presentation signed with the following challenge:
    const challenge = "475a7984-1bb5-4c4c-a56f-822bccd46440";
    // The verifier and holder also agree that the signature should have an expiry date
    // 10 minutes from now.

    // A unique random challenge generated by the requester per presentation can mitigate replay attacks
    // (along with other properties like `expires` and `domain`).

    // Sign the verifiable presentation with the holder's private key and include the requested challenge and expiry timestamp.
    const signedVp = alice.doc.signPresentation(unsignedVp, {
        method: "#sign-0",
        private: Array.from(alice.key.private()),
    }, new SignatureOptions({
        challenge: challenge,
        expires: Timestamp.nowUTC().checkedAdd(Duration.minutes(10))
    }));

    // Convert the Verifiable Presentation to JSON to send it to the verifier.
    const signedVpJSON = signedVp.toJSON();


    // ===========================================================================
    // Verifier - receives a verifiable presentation from the holder and validates it.
    // ===========================================================================

    // Deserialize the presentation from the holder.
    const presentation = Presentation.fromJSON(signedVpJSON);

    // The verifier wants the following requirements to be satisfied:
    // - Signature verification (including checking the requested challenge to mitigate replay attacks)
    // - Presentation validation must fail if credentials expiring within the next 10 hours are encountered
    // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property
    // - The issuance date must not be in the future.

    // Declare that the challenge must match our expectation:
    const presentationVerifierOptions = new VerifierOptions({
        challenge: "475a7984-1bb5-4c4c-a56f-822bccd46440",
        allowExpired: false,
    });

    // Declare that any credential contained in the presentation are not allowed to expire within the next 10 hours:
    const earliestExpiryDate = Timestamp.nowUTC().checkedAdd(Duration.hours(10));
    const credentialValidationOptions = new CredentialValidationOptions({
        earliestExpiryDate: earliestExpiryDate,
    });

    // Declare that the presentation holder's DID must match the subject ID on all credentials in the presentation.
    const subjectHolderRelationship = SubjectHolderRelationship.AlwaysSubject;

    const presentationValidationOptions = new PresentationValidationOptions({
        sharedValidationOptions: credentialValidationOptions,
        presentationVerifierOptions: presentationVerifierOptions,
        subjectHolderRelationship: subjectHolderRelationship,
    });

    // In order to validate presentations and credentials one needs to resolve the DID Documents of
    // the presentation holder and of credential issuers. This is something the `Resolver` can help with.
    const resolver = await Resolver
        .builder()
        .clientConfig({
            network: clientConfig.network
        })
        .build();

    // Validate the presentation and all the credentials included in it according to the validation options
    await resolver.verifyPresentation(
        presentation,
        presentationValidationOptions,
        FailFast.FirstError
    );
    // Since no errors were thrown by `verifyPresentation` we know that the validation was successful.
    console.log(`VP successfully validated`);

    // Note that the `verifyPresentation` method we called automatically resolved all DID Documents that are necessary to validate the presentation.
    // It is also possible to supply extra arguments to avoid some resolutions if one already has up-to-date resolved documents of
    // either the holder or issuers (see the method's documentation).
}

export {createVP};
